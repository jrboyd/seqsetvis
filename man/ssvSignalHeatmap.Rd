% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_signal_plots.R
\name{ssvSignalHeatmap}
\alias{ssvSignalHeatmap}
\title{heatmap style representation of membership table. instead of clustering, each
column is sorted starting from the left.}
\usage{
ssvSignalHeatmap(
  bw_data,
  nclust = 6,
  perform_clustering = c("auto", "yes", "no")[1],
  row_ = "id",
  column_ = "x",
  fill_ = "y",
  facet_ = "sample",
  cluster_ = "cluster_id",
  max_rows = 500,
  max_cols = 100,
  fill_limits = NULL,
  clustering_col_min = -Inf,
  clustering_col_max = Inf,
  within_order_strategy = c("hclust", "sort")[2],
  dcast_fill = NA,
  return_data = FALSE,
  show_cluster_bars = TRUE,
  rect_colors = c("black", "gray"),
  text_colors = rev(rect_colors),
  show_labels = TRUE,
  label_angle = 0,
  fun.aggregate = "mean"
)
}
\arguments{
\item{bw_data}{a GRanges or data.table of bigwig signal. As returned from
\code{\link{ssvFetchBam}} and \code{\link{ssvFetchBigwig}}}

\item{nclust}{number of clusters}

\item{perform_clustering}{should clustering be done? default is auto. auto
considers if row_ has been ordered by being a factor and if cluster_ is a
numeric.}

\item{row_}{variable name mapped to row, likely id or gene name for ngs data.
Default is "id" and works with ssvFetch* output.}

\item{column_}{varaible mapped to column, likely bp position for ngs data.
Default is "x" and works with ssvFetch* output.}

\item{fill_}{numeric variable to map to fill. Default is "y" and works with
ssvFetch* output.}

\item{facet_}{variable name to facet horizontally by. Default is "sample" and
works with ssvFetch* output. Set to "" if data is not facetted.}

\item{cluster_}{variable name to use for cluster info. Default is
"cluster_id".}

\item{max_rows}{for speed rows are sampled to 500 by default, use Inf to plot
full data}

\item{max_cols}{for speed columns are sampled to 100 by default, use Inf to
plot full data}

\item{fill_limits}{limits for fill legend.  values will be cropped to this
range if set.  Default of NULL uses natural range of fill_.}

\item{clustering_col_min}{numeric minimum for col range considered when
clustering, default in -Inf}

\item{clustering_col_max}{numeric maximum for col range considered when
clustering, default in Inf}

\item{within_order_strategy}{one of "hclust" or "sort".  if hclust,
hierarchical clustering will be used. if sort, a simple decreasing sort of
rosSums.}

\item{dcast_fill}{value to supply to dcast fill argument. default is NA.}

\item{return_data}{logical.  If TRUE, return value is no longer ggplot and is
instead the data used to generate that plot. Default is FALSE.}

\item{show_cluster_bars}{if TRUE, show bars indicating cluster membership.}

\item{rect_colors}{colors of rectangle fill, repeat to match number of
clusters. Default is c("black", "gray").}

\item{text_colors}{colors of text, repeat to match number of clusters.
Default is reverse of rect_colors.}

\item{show_labels}{logical, shoud rectangles be labelled with cluster
identity.  Default is TRUE.}

\item{label_angle}{angle to add clusters labels at.  Default is 0, which is
horizontal.}

\item{fun.aggregate}{Function to aggregate when multiple values present for
facet_, row_, and column_. Affects both clustering and plotting. The
function should accept a single vector argument or be a character string
naming such a function.}
}
\value{
ggplot heatmap of signal profiles, facetted by sample
}
\description{
See \code{\link{ssvSignalHeatmap.ClusterBars}} for an alternative with more
control over where the cluster bars appear.
}
\examples{
#the simplest use
ssvSignalHeatmap(CTCF_in_10a_profiles_gr)
ssvSignalHeatmap(CTCF_in_10a_profiles_gr, show_cluster_bars = FALSE)

#clustering can be done manually beforehand
clust_dt = ssvSignalClustering(CTCF_in_10a_profiles_gr, nclust = 3)
ssvSignalHeatmap(clust_dt)

ssvSignalHeatmap(clust_dt, max_rows = 20, max_cols = 7)

# aggregation, when facet_ is shared by multiple samples
prof_gr = CTCF_in_10a_profiles_gr
prof_gr$mark = "CTCF"
clust_gr = ssvSignalClustering(
  prof_gr,
  facet_ = "mark",
  fun.aggregate = function(x)as.numeric(x > 10)
)
table(clust_gr$y)
ssvSignalHeatmap(prof_gr, facet_ = "mark",
  fun.aggregate = function(x)as.numeric(x > 10))
ssvSignalHeatmap(prof_gr, facet_ = "mark",
  fun.aggregate = max)
ssvSignalHeatmap(prof_gr, facet_ = "mark",
  fun.aggregate = min)
}
